# Implement depth first search
# Input: A node n, value v
# Output: a boolean representing whether the node is in the tree
# Extra challenge: Efficiently print the path you took to find the node
def depth_first_search(node, v):
    return ''

#Implement breadth first search
# Input: A node n, value v
# Output: a boolean representing whether the node is in the tree
# Extra challenge: Efficiently print the path you took to find the node.
# Compare the paths between depth and breadth first. What is the best time to use
# each type of search.
def breadth_first_search(node, v):
    return ''

#Write a function that returns the lowest common ancestor of two nodes.
# the lowest node in T that has both n1 and n2 as descendants

# Define a tree structure - start with a tree with two nodes.
# For an extra challenge, ask yourself how the implementation would
# change if there are more than two branches per node. An example of this would be a Trie.
# These are very useful for autocomplete and the like

# This is a common problem, however when we master this + (depth + breadth)
# first search tree problems will become second nature as the traversal is the same
# and the only conditions that usually change are which direction you take when

def lowest_common_ancestor(node, v1, v2):
    return ''

#Instead of 2 nodes, what if we had a list of nodes.
def challenge_lowest_common_ancestor(node, alon):
    return ''

# For a really fun exercise think about the differences between cyclical and acyclical graphs.
# Question: Thinking about google maps, what kind of graph are roads.
# Graph theory is all around us in various ways. When we complete these we
# can head into problems that deal with more interesting trees for example AVL
# trees and Red-Black Trees (self balancing trees)
