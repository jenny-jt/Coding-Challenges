#Implement breadth first search
# Input: A node n, value v
# Output: a boolean representing whether the node is in the tree
# Extra challenge: Efficiently print the path you took to find the node.
# Compare the paths between depth and breadth first. What is the best time to use
# each type of search.
def breadth_first_search(node, v):
    """given node n with value v, return True if node is in tree, 
    return False if not
    breadth_first_search(node, v)
    """
    return



# Implement depth first search
# Input: A node n, value v
# Output: a boolean representing whether the node is in the tree
# Extra challenge: Efficiently print the path you took to find the node
def depth_first_search(node, v):
    return ''



#Write a function that returns the lowest common ancestor of two nodes.
# the lowest node in T that has both n1 and n2 as descendants




# This is a common problem, however when we master this + (depth + breadth)
# first search tree problems will become second nature as the traversal is the same
# and the only conditions that usually change are which direction you take when

def lowest_common_ancestor(node, v1, v2):
    return ''

#Instead of 2 nodes, what if we had a list of nodes.
def challenge_lowest_common_ancestor(node, alon):
    return ''


# Graph theory is all around us in various ways. When we complete these we
# can head into problems that deal with more interesting trees for example AVL
# trees and Red-Black Trees (self balancing trees)


